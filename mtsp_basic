from ortools.constraint_solver import routing_enums_pb2
from ortools.constraint_solver import pywrapcp

import math

class agent():
    def __init__(self, position):
        self.pos = position

class task():
    def __init__(self, position):
        self.pos = position

def create_data_model():
    data = {}
    data['distance_matrix'] = [
        	[0, 1, 2, 3, 4],
            [0, 0, 2, 3, 4], 
            [0, 1, 0, 3, 4],
            [0, 1, 2, 0, 4],
            [0, 1, 2, 3, 0],
    ]
    data['num_agents'] = 2
    data['starts'] = [0, 3]
    data['ends'] = [0, 0]
    return data

def create_model(agents, tasks):
    data = {}
    data['distance_matrix'] = [
        	[0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0], 
            [0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0],
    ]
    for i in range(len(tasks)):
        for j in range(len(tasks)):
            if i != j:
                data['distance_matrix'][i][j] = round(math.dist(tasks[i].pos, tasks[j].pos))
    data['num_agents'] = len(agents)
    data['starts'] = [0, 0]
    data['ends'] = [0, 0]
    return data


def get_routes(solution, routing, manager):
    routes = []
    for route_nbr in range(routing.vehicles()):
        index = routing.Start(route_nbr)
        route = [manager.IndexToNode(index)]
        while not routing.IsEnd(index):
            index = solution.Value(routing.NextVar(index))
            route.append(manager.IndexToNode(index))
        routes.append(route)
    return routes

def main():
    agents = [
        agent([-5, -1]),
        agent([3, -1]),
    ]

    tasks = [
        task([-8, 6]),
        task([-6, -6]),
        task([-2, 3]),
        task([6, -5]),
        task([8, 5]),
    ]
    data = create_model(agents, tasks)

    manager = pywrapcp.RoutingIndexManager(len(data['distance_matrix']), 
                                            data['num_agents'], 
                                            data['starts'], data['ends'])
    routing = pywrapcp.RoutingModel(manager)

    def distance_callback(from_index, to_index):
        from_node = manager.IndexToNode(from_index)
        to_node = manager.IndexToNode(to_index)
        return data['distance_matrix'][from_node][to_node]

    transit_callback_index = routing.RegisterTransitCallback(distance_callback)

    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)

    dimension_name = 'Distance'
    routing.AddDimension(
        transit_callback_index, 
        0, 
        100, 
        True, 
        dimension_name)
    distance_dimension = routing.GetDimensionOrDie(dimension_name)
    distance_dimension.SetGlobalSpanCostCoefficient(100)

    search_parameters = pywrapcp.DefaultRoutingSearchParameters()
    search_parameters.first_solution_strategy = (
        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC)

    solution = routing.SolveWithParameters(search_parameters)
    routes = get_routes(solution, routing, manager)
    for i, route in enumerate(routes):
        print('Route', i, route)

if __name__ == '__main__':
    main()
